package main

//go:generate go run generator.go

import (
	"bytes"
	"fmt"
	"github.com/fatih/color"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"text/template"
)

const (
	fieldsFileName      = "./fields.go"
	fieldsTestsFileName = "./fields_test.go"
)

// Сообщения в консоли с цветом
var (
	ColoredError = color.New(color.FgRed).PrintfFunc()
	Success      = color.New(color.FgGreen).PrintfFunc()
)

func main() {
	generateTests()
}

// generateFieldsTests генерирует тесты для сгенерированных полей
func generateTests() {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, fieldsFileName, nil, 0)
	if err != nil {
		ColoredError("error parsing file: %s\n", err)
		return
	}
	out, _ := os.Create(fieldsTestsFileName)
	defer out.Close()

	result := "// Code generated by Generator. DO NOT EDIT.\n" +
		"// Source: " + fieldsFileName + "\n\n" +
		"package " + node.Name.Name + "\n\n" +
		"import (\n" +
		"\t\"fmt\"\n" +
		"\t\"go.uber.org/zap\"\n" +
		"\t\"reflect\"\n" +
		"\t\"testing\"\n" +
		")\n\n"
	for _, f := range node.Decls {
		g, ok := f.(*ast.FuncDecl)
		if !ok { // пропускаем все кроме определения методов
			continue
		}
		if len(g.Type.Params.List) == 0 { // пропускаем если у метода нет параметров
			continue
		}
		if len(g.Body.List) == 0 { // пропускаем если у метода нет тела
			continue
		}

		// тип переменной
		valueType := g.Type.Params.List[0].Type.(*ast.Ident)

		test := generateTestVariant(g, valueType.Name)

		message, err := ioutil.ReadFile("./templates/test.gohtml")
		if err != nil {
			ColoredError("error reading tpl: %s", err)
			return
		}

		tpl, err := template.New("test").Parse(string(message))
		if err != nil {
			ColoredError("error allocating new template: %s", err)
			return
		}

		var testResult bytes.Buffer
		err = tpl.Execute(&testResult, struct {
			FuncName  string
			ValueType string
			Test      string
		}{
			FuncName:  g.Name.Name,
			ValueType: valueType.Name,
			Test:      test,
		})
		if err != nil {
			ColoredError("error executing template: %s", err)
			return
		}

		result += testResult.String()
	}
	fmt.Fprint(out, result)
	Success("Fields tests created\n")
}

// generateTestVariant Генерирует вариант теста для конкретного метода. Работает с AST деревом
func generateTestVariant(g *ast.FuncDecl, valueType string) string {
	test := `{},`
	testName := "correct"
	methodBody := g.Body.List[0].(*ast.ReturnStmt).Results[0].(*ast.CallExpr)
	returnFunc := methodBody.Fun
	if selector, ok := returnFunc.(*ast.SelectorExpr); ok {
		zapMethod := selector.Sel.Name
		switch zapMethod {
		case "String":
			value := "test_string"
			valName := methodBody.Args[0].(*ast.BasicLit).Value
			test = `{"` + testName + `", "` + value + `", zap.` + zapMethod + `(` + valName + `, "` + value + `")},`
		case "Int64":
			value := "123"
			valName := methodBody.Args[0].(*ast.BasicLit).Value
			test = `{"` + testName + `", int64(` + value + `), zap.` + zapMethod + `(` + valName + `, int64(` + value + `))},`
		case "Error":
			value := `fmt.Errorf("boo")`
			test = `{"` + testName + `", ` + value + `, zap.` + zapMethod + `(` + value + `)},`
		}
	}
	if citizapMethod, ok := returnFunc.(*ast.Ident); ok {
		valType := methodBody.Args[0].(*ast.CallExpr).Fun.(*ast.Ident).Name
		value := "123"
		test = `{"correct", ` + valueType + `(` + value + `), ` + citizapMethod.Name + `(` + valType + `(` + value + `))},`
	}
	return test
}
